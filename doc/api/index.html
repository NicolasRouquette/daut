<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="lib/jquery.js"></script><script type="text/javascript" src="lib/index.js"></script><script type="text/javascript" src="index.js"></script><script type="text/javascript" src="lib/scheduler.js"></script><script type="text/javascript" src="lib/template.js"></script><script type="text/javascript" src="lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 current" name="_root_.root" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">root</span></span></li><li class="indented1 " name="_root_.daut" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="daut"></a><a id="daut:daut"></a> <span class="permalink"><a href="index.html#daut" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="daut/index.html" title="Daut (Data automata) is an internal Scala DSL for writing event stream monitors."><span class="name">daut</span></a></span><p class="shortcomment cmt">Daut (Data automata) is an internal Scala DSL for writing event stream monitors.</p><div class="fullcomment"><div class="comment cmt"><p>Daut (Data automata) is an internal Scala DSL for writing event stream monitors. It
supports flavors of state machines, temporal logic, and rule-based programming, all in one
unified formalism. The underlying concept is that at any point during monitoring there is an
active set of states, the _state soup_. States can be added and removed from this soup.
Each state in the soup either monitors the incoming event stream, or is used by other states to record
data (as in rule-based programming).</p><p>The specification language specifically supports:</p><ul><li>Automata, represented by states, parameterized with data (thereby the name Daut: Data automata).</li><li>Temporal operators which generate states, resulting in more succinct specifications.</li><li>Rule-based programming in that one can test for the presence of states and one can add states.</li><li>General purpose programming in Scala when the other specification features fall short.</li></ul><p>The DSL is a simplification of the TraceContract (<a href="https://github.com/havelund/tracecontract" target="_blank">https://github.com/havelund/tracecontract</a>) internal Scala DSL by an order of magnitude less code.</p><p>The general idea is to create a monitor as a class sub-classing the <code>Monitor</code> class,
create an instance of it, and then feed it with events with the <code>verify(event: Event)</code> method,
one by one, and in the case of a finite sequence of observations, finally calling the
<code>end()</code> method on it. If <code>end()</code> is called, it will be determined whether
there are any outstanding obligations that have not been satisfied (expected events that did not occur).</p><p>This can schematically be illustrated as follows:</p><pre><span class="kw">class</span> MyMonitor <span class="kw">extends</span> Monitor[SomeType] {
...
}

<span class="kw">object</span> Main {
  <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]) {
    <span class="kw">val</span> m = <span class="kw">new</span> MyMonitor()
    m.verify(event1)
    m.verify(event2)
    ...
    m.verify(eventN)
    m.end()
  }
}</pre></div></div></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><h1>root package <span class="permalink"><a href="index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">root</span></span></h4><div id="comment" class="fullcommenttop"></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="_root_.daut" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="daut"></a><a id="daut:daut"></a> <span class="permalink"><a href="index.html#daut" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="daut/index.html" title="Daut (Data automata) is an internal Scala DSL for writing event stream monitors."><span class="name">daut</span></a></span><p class="shortcomment cmt">Daut (Data automata) is an internal Scala DSL for writing event stream monitors.</p><div class="fullcomment"><div class="comment cmt"><p>Daut (Data automata) is an internal Scala DSL for writing event stream monitors. It
supports flavors of state machines, temporal logic, and rule-based programming, all in one
unified formalism. The underlying concept is that at any point during monitoring there is an
active set of states, the _state soup_. States can be added and removed from this soup.
Each state in the soup either monitors the incoming event stream, or is used by other states to record
data (as in rule-based programming).</p><p>The specification language specifically supports:</p><ul><li>Automata, represented by states, parameterized with data (thereby the name Daut: Data automata).</li><li>Temporal operators which generate states, resulting in more succinct specifications.</li><li>Rule-based programming in that one can test for the presence of states and one can add states.</li><li>General purpose programming in Scala when the other specification features fall short.</li></ul><p>The DSL is a simplification of the TraceContract (<a href="https://github.com/havelund/tracecontract" target="_blank">https://github.com/havelund/tracecontract</a>) internal Scala DSL by an order of magnitude less code.</p><p>The general idea is to create a monitor as a class sub-classing the <code>Monitor</code> class,
create an instance of it, and then feed it with events with the <code>verify(event: Event)</code> method,
one by one, and in the case of a finite sequence of observations, finally calling the
<code>end()</code> method on it. If <code>end()</code> is called, it will be determined whether
there are any outstanding obligations that have not been satisfied (expected events that did not occur).</p><p>This can schematically be illustrated as follows:</p><pre><span class="kw">class</span> MyMonitor <span class="kw">extends</span> Monitor[SomeType] {
...
}

<span class="kw">object</span> Main {
  <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]) {
    <span class="kw">val</span> m = <span class="kw">new</span> MyMonitor()
    m.verify(event1)
    m.verify(event2)
    ...
    m.verify(eventN)
    m.end()
  }
}</pre></div></div></li></ol></div></div><div id="inheritedMembers"></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
